<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*jshint indent:2, laxcomma:true, nomen:false*/
/* This file&#39;s documentation is compiled with JsDuck. */
var util = require(&#39;util&#39;);
var events = require(&#39;events&#39;);
var assert = require(&#39;assert-plus&#39;);
var deep = require(&#39;deep-diff&#39;);
var JsonPointer = require(&#39;json-ptr&#39;);
var utils = require(&#39;./utils&#39;);
var errors = require(&#39;./errors&#39;);
var format = util.format;



<span id='MongoRepo'>/**
</span> * @author Phillip Clark &lt;phillip@flitbit.com&gt;
 * Creates a new MongoRepo on the specified mongo `db`, and whose behavior is controlled by `options`.
 * @class
 * @extends EventEmitter
 *
 * @param {object} db - The MongoClient instance where the repository gets its collection.
 * @param {object} options - Initialization options for the repository.
 * @param {string} option.collection - The name of the collection on MongoDb where this repository&#39;s data is stored.
 * @param {(string|MongoRepo~identityAccessor)} [option.id=&quot;_id&quot;] - Either an optional property name that identifies which of the domain model&#39;s properties corresponds to an instance&#39;s identity or an {@link identityAccessor} callback that returns the model&#39;s identity.
 * @param {string} [option.descriptiveName=&quot;Data model&quot;] - An optional descriptive name for the domain model; used in logging and error messages.
 * @param {string[]} [option.timestampOnCreate=[]] - An optional array of JSON Pointers identifying property paths that the repository will set to the current UTC date when #create() is called.
 * @param {string[]} [option.timestampOnUpdate=[]] - An optional array of JSON Pointers identifying property paths that the repository will set to the current UTC date when #update() is called.
 *
 * This repository implementation is one-to-one with a domain model. Its purpose is to provide boilerplate CRUD operations for a single domain model.
 *
 */
function MongoRepo(db, options) {
<span id='MongoRepo-method-'>  /**
</span>   * @function MongoRepo~identityAccessor - Callback function that accesses the specified model&#39;s `identity`.
   * @param {object} model - An instance of the repository&#39;s domain model.
   * @returns {string} The specified model&#39;s id.
   */

  assert.object(db, &#39;db&#39;);
  assert.object(options, &#39;options&#39;);
  assert.string(options.collection, &#39;options.collection&#39;);
  assert.optionalString(options.descriptiveName, &#39;options.descriptiveName&#39;);
  assert.optionalArrayOfString(options.timestampOnCreate, &#39;options.timestampOnCreate&#39;);
  assert.optionalArrayOfString(options.timestampOnUpdate, &#39;options.timestampOnUpdate&#39;);

  events.EventEmitter.call(this);

  var _idOp;

  var _timestampOnCreate = utils.prepareJsonPointers(options.timestampOnCreate);
  var _timestampOnUpdate = utils.prepareJsonPointers(options.timestampOnUpdate);

  Object.defineProperties(this, {

<span id='MongoRepo-property-_descriptiveName'>    /**
</span>     * The descriptive name of the domain model; used by the base class when generating errors and log messages.
     * @property {string} _descriptiveName
     */
    _descriptiveName: { value: options.descriptiveName || &#39;Domain model&#39; },

<span id='MongoRepo-method-_dataIdFromModel'>    /**
</span>     * Gets the identity (as seen by the data model) from the specified domain model.
     * @method _dataIdFromModel
     *
     * @param {object} model - An instance of the repository&#39;s domain model.
     * @return {string} The specified model&#39;s id.
     */
    _dataIdFromModel: {
      get: function () { return _idOp; },
      set: function (val) {
        // val may be either a property name (string), or a function that returns a model&#39;s identity.
        var idt = typeof val;
        if (idt === &#39;string&#39;) {
          _idOp = function (model) {
            if (model) {
              return model[val];
            }
          };
        } else if (idt === &#39;function&#39;) {
          _idOp = val;
        } else {
          throw new TypeError(&quot;option.id must be either the name of a property (string) or a function/1, returning a model&#39;s identity&quot;);
        }
      },
      enumerable: true
    },

<span id='MongoRepo-property-_timestampOnCreate'>    /**
</span>     * An array of JSON pointers identifying property paths that the repository will set to the current UTC date when {link MongoRepo#create} is called.
     * @property {JsonPointer[]|string[]} _timestampOnCreate
     */
    _timestampOnCreate: {
      get: function () { return _timestampOnCreate; },
      set: function (val) {
        assert.arrayOfString(val, &#39;_timestampOnCreate&#39;);
        _timestampOnCreate = utils.prepareJsonPointers(val);
      },
      enumerable: true
    },

<span id='MongoRepo-property-_timestampOnUpdate'>    /**
</span>     * An array of JSON pointers identifying property paths that the repository will set to the current UTC date when {link MongoRepo#update} is called.
     * @property {JsonPointer[]|string[]} _timestampOnUpdate
     */
    _timestampOnUpdate: {
      get: function () { return _timestampOnUpdate; },
      set: function (val) {
        assert.arrayOfString(val, &#39;_timestampOnUpdate&#39;);
        _timestampOnUpdate = utils.prepareJsonPointers(val);
      },
      enumerable: true
    },

<span id='MongoRepo-property-_db'>    /**
</span>     * Provides access to the MongoClient instance used by the repository.
     * @property {MongoClient} _db
     */
    _db: { value: db },

<span id='MongoRepo-property-_namespace'>    /**
</span>     * @property {string} _namespace The name of the repository&#39;s data collection on the MongoDB backend.
     */
    _namespace: { value: options.collection },

<span id='MongoRepo-property-_collection'>    /**
</span>     * @property {MongoCollection} _collection The mongodb collection underlying the repository&#39;s operations.
     */
    _collection: { value: db.collection(options.collection) }

  });

  this._dataIdFromModel = (options.id || &quot;_id&quot;);
}
util.inherits(MongoRepo, events.EventEmitter);



Object.defineProperties(MongoRepo.prototype, {

  _transformData: {
    value: function _transformData(data) {
      return data;
    },
    enumerable: true,
    writable: true
  },

  _transformModel: {
    value: function _transformModel(model) {
      return model;
    },
    enumerable: true,
    writable: true
  },

  _beforeCreateDataModel: {
    value: function _beforeCreateDataModel(data) {
      var pointers = this._timestampOnCreate;
      if (pointers) {
        utils.setTimestampForAllPointers(data, pointers);
      }
      return data;
    },
    enumerable: true,
    writable: true
  },

  _beforeUpdateDataModel: {
    value: function _beforeUpdateDataModel(data) {
      var pointers = this._timestampOnUpdate;
      if (pointers) {
        utils.setTimestampForAllPointers(data, pointers);
      }
      return data;
    },
    enumerable: true,
    writable: true
  },

  _makeUpdateSet: {
    value: function _makeUpdateSet(orig, updated) {
      var changes = [];
      deep.observableDiff(orig, updated,
        function (change) { changes.push(change); },
        this._filterUpdatedProperties.bind(this)
        );
      var edited
      , removed
      , i = -1
      , len = changes.length
      ;
      if (len) {
        while (++i &lt; len) {
          if (changes[i].kind === &#39;E&#39; || changes[i].kind === &#39;N&#39;) {
            if (!edited) { edited = {}; }
            edited[changes[i].path.join(&#39;.&#39;)] = changes[i].rhs;
          } else {
            if (!removed) { removed = {}; }
            removed[changes[i].path.join(&#39;.&#39;)] = 1;
          }
        }
      }
      var res = {};
      if (edited) { res.$set = edited; }
      if (removed) { res.$unset = removed; }
      return res;
    },
    enumerable: true,
    writable: true
  },

  _objectNotFound: {
    get: function get_objectNotFound() {
      var self = this;
      return this.handleObjectNotFound || function default_ObjectNotFound(id, callback) {
        callback(new errors.NotFoundError(format(&#39;%s not found: %s.&#39;, self._descriptiveName, id)));
      };
    },
    enumerable: true
  },

  _objectNotFoundOnUpdate: {
    get: function get_objectNotFoundOnUpdate() {
      var self = this;
      return this.handleObjectNotFoundOnUpdate || function default_ObjectNotFoundOnUpdate(model, callback) {
        self._objectNotFound(self._dataIdFromModel(model, callback));
      };
    },
    enumerable: true
  },

  validate: {
    value: function validate(model, callback) {
      callback();
    },
    enumerable: true,
    writable: true
  },

  translateDbError: {
    value: function translateDbError(err) {
      var msg = (typeof err === &#39;string&#39;) ? err : err.message;

      if (msg.indexOf(&#39;duplicate key error&#39;) &gt; 0) {
        return new errors.ConflictError(&#39;Creating the resource would cause a conflict on the server.&#39;);
      }

      return err;
    },
    enumerable: true
  },

  getById: {
    value: function getById(id, callback) {
      assert.string(id, &#39;id&#39;);
      var self = this;
      this._collection.findOne({_id: id}, function (err, data) {
        if (err) { return callback(err); }
        if (data === null) {
          return self._objectNotFound(id, callback);
        }
        var model = self._transformData(data);
        self.emit(&#39;fetched&#39;, {id: id, model: model});
        callback(null, model);
      });
    },
    enumerable: true,
    writable: true
  },

  findMatch: {
    value: function find(match, callback) {
      assert.object(match, &#39;match&#39;);
      var self = this;
      try {
        callback(null, this._collection.find(match));
      } catch (err) {
        callback(err);
      }
    },
    enumerable: true,
    writable: true
  },

<span id='MongoRepo-method-create'>  /**
</span>   * @member MongoRepo
   * @method
   * Creates the data model on the underlying storage for the specified domain model.
   * @param {object} model The domain model supplying data to the underlying data model.
   * @param {function} callback A callback function invoked by the repository when the operation completes.
   */
  create: {
    value: function create(model, callback) {
      assert.object(model, &#39;model&#39;);
      var self = this;
      this.validate(model, function postValidateCreate(err) {
        if (err) { return callback(err); }
        var data = self._transformModel(model);
        data = self._beforeCreateDataModel(data);

        self._collection.insert(data, {w: 1}, function (err, res) {
          if (err) { return callback(self.translateDbError(err)); }
          var model = self._transformData(res[0]);
          self.emit(&#39;created&#39;, { id: model.referenceId, model: model});
          callback(null, model);
        });
      });
    },
    enumerable: true,
    writable: true
  },

  batchCreate: {
    value: function create(models, callback) {
      assert.arrayOfObject(models, &#39;models&#39;);
      var self = this
      , i = -1
      , len = models.length
      , last = len - 1
      , count = 0
      , invalid = []
      , valid = []
      , ea = function (index, model, err) {
          if (err) {
            invalid.push({index: index, model: models[index], error: err});
          } else {
            valid.push(self._transformModel(models[index]));
          }
          if (++count === len) {
            if (invalid.length) {
              return callback(invalid);
            }
            self._collection.insert(valid, {w: 1}, function (err, res) {
              if (err) { return callback(self.translateDbError(err)); }
              var j = -1
              , jlen = res.length
              ;
              while (++j &lt; jlen) {
                res[j] = self._transformData(res[j]);
              }
              self.emit(&#39;created&#39;, { models: res});
              callback(null, res);
            });
          }
        }
      ;

      while (++i &lt; len) {
        this.validate(models[i], ea.bind(this, i, models[i]));
      }
    },
    enumerable: true,
    writable: true
  },

  update: {
    value: function update(model, callback) {
      assert.object(model, &#39;model&#39;);
      var self = this;
      this.validate(model, function postValidateUpdate(err) {
        if (err) { return callback(err); }

        var updated = self._transformModel(model);
        var id = self._dataIdFromModel(model);
        var idRef = { _id: id };
        self._collection.findOne(idRef, function (err, data) {
          if (err) { return callback(self.translateDbError(err)); }
          if (data === null) {
            return self._objectNotFoundOnUpdate(model, callback);
          }

          var changes = self._makeUpdateSet(data, updated);
          if (changes.$set || changes.$unset) {
            if (self._timestampOnUpdate) {
              var timestamps = {};
              utils.setValueForAllPointers(timestamps, self._timestampOnUpdate, true);
              changes.$currentDate = timestamps;
            }
            if (self._afterMakeUpdateSet) {
              changes = self._afterMakeUpdateSet(data, updated, changes);
            }
            self._collection.update(idRef, changes, function (err, res) {
              if (err) { return callback(self.translateDbError(err)); }
              if (res) {
                self.emit(&#39;updated&#39;, { _id: id, changes: changes });
                callback(null, res);
              } else {
                self._objectNotFoundOnUpdate(model, callback);
              }
            });
          } else {
            callback();
          }
        });

      });
    },
    enumerable: true
  },

  del: {
    value: function del(id, callback) {
      assert.string(id, &#39;id&#39;);
      var self = this;
      self._collection.remove({_id: id}, {w: 1}, function (err, res) {
        if (err) { return callback(self.translateDbError(err)); }
        if (res) {
          self.emit(&#39;deleted&#39;, id);
        }
        callback(null, res);
      });
    },
    enumerable: true
  },

  delMatch: {
    value: function del(match, callback) {
      assert.object(match, &#39;match&#39;);
      var self = this;
      self._collection.remove(match, {w: 1}, function (err, res) {
        if (err) { return callback(self.translateDbError(err)); }
        if (res) {
          self.emit(&#39;deleted&#39;, { match: match, count: res });
        }
        callback(null, res);
      });
    },
    enumerable: true
  }

});

module.exports = MongoRepo;</pre>
</body>
</html>
